using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Piclip.Generator.Models;
using System;
using System.Collections.Frozen;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

namespace Piclip.Generator;

[Generator(LanguageNames.CSharp)]
public class EntityGenerator : IIncrementalGenerator
{
    private const string DeclaredEntityAttribute = """
        using System;

        namespace Paper.Generator;

        [AttributeUsage(AttributeTargets.Struct)]
        public class DeclaredEntityAttribute(params Type[] types) : Attribute
        {
            private readonly Type[] _types = types;
        }
        """;

    private const string DeclaredEntityAttributeMetadataName = "Paper.Generator.DeclaredEntityAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(c => c.AddSource("DeclaredEntityAttribute.g.cs", DeclaredEntityAttribute));

        IncrementalValuesProvider<DeclaredEntityModel> models = 
            context.SyntaxProvider.ForAttributeWithMetadataName(DeclaredEntityAttributeMetadataName, (node, _) => true, CreateEntityModel);

        var sourceFiles = models.Select(ModelToSource);

        context.RegisterSourceOutput(sourceFiles, (ctx, source) =>
        {
            if (source == default)
                return;
            ctx.AddSource(source.Name, source.Source);
        });
    }
    
    private static DeclaredEntityModel CreateEntityModel(GeneratorAttributeSyntaxContext context, CancellationToken ct)
    {
        StructDeclarationSyntax type = (StructDeclarationSyntax)context.TargetNode;

        INamedTypeSymbol? namedTypeSymbol = context.SemanticModel.GetDeclaredSymbol(type, ct);
        if(namedTypeSymbol is null) return default;

        (string Namespace, string Name)[] values = 
            context
            .Attributes[0]
            .ConstructorArguments[0]
            .Values
            .Select(c => c.Value as INamedTypeSymbol)
            .Where(o => o is not null)
            .Select(n => (n!.ContainingNamespace.ToString(), n.Name))
            .ToArray();

        return new DeclaredEntityModel(namedTypeSymbol.Name, namedTypeSymbol.ContainingNamespace.ToString(), new EquatableArray<(string, string)>(values));
    }

    private static (string Name, string Source) ModelToSource(DeclaredEntityModel model, CancellationToken ct)
    {
        if (model == default)
            return default;

        CodeBuilder codeBuilder = new CodeBuilder();

        codeBuilder
            .AppendLine("// <auto-generated/>")
            .AppendLine()
            .Append("namespace ").Append(model.Namespace).AppendLine(';')
            .AppendLine()
            .Append("partial struct ").AppendLine(model.TypeName)
            .Scope()
                .Foreach(model.PropertyTypes, ct, (in (string @namespace, string name) param, CodeBuilder builder, CancellationToken ct) =>
                {
                    if (param.name == model.TypeName)
                        return;

                    builder
                        .Append("public ref global::")
                        .Append(param.@namespace)
                        .Append('.')
                        .Append(param.name)
                        .Append(' ')
                        .Append(param.name)
                        .Append(" => ref global::Frent.Marshalling.WorldMarshal.GetComponent<global::").Append(param.@namespace).Append('.').Append(param.name).AppendLine(">(_world, _self);");
                    ct.ThrowIfCancellationRequested();
                })
                .AppendLine()
                .AppendLine("private readonly global::Frent.World _world;")
                .AppendLine("private readonly global::Frent.Entity _self;")
                .AppendLine()
                .Append("private ").Append(model.TypeName).Append("(global::Frent.World world")
                .Foreach(model.PropertyTypes, ct, (in (string @namespace, string name) param, CodeBuilder builder, CancellationToken ct) =>
                {
                    builder
                            .Append(", global::")
                            .Append(param.@namespace)
                            .Append('.')
                            .Append(param.name)
                            .Append(' ')
                            .Append(char.ToLowerInvariant(param.name[0]))
                            .Append(param.name.AsSpan(1));
                })
                .AppendLine(')')
                .Scope()
                    .AppendLine("_world = world;")
                    .Append("_self = world.Create(")
                    .Foreach(model.PropertyTypes, ct, (in (string @namespace, string name) param, CodeBuilder builder, CancellationToken ct) =>
                    {
                        builder
                            .Append(char.ToLowerInvariant(param.name[0]))
                            .Append(param.name.AsSpan(1))
                            .Append(", ");
                    })
                    .Append("new global::Paper.Core.Editor.EditorName(nameof(global::").Append(model.Namespace).Append('.').Append(model.TypeName).AppendLine(")));")
                .Unscope()
            .Unscope();

        return ($"{model.TypeName}.g.cs", codeBuilder.ToString());
    }

    static bool Launched = false;

    [Conditional("DEBUG")]
    [DebuggerStepThrough]
    [DebuggerHidden]
    internal static void LaunchDebugger()
    {
        if (!Debugger.IsAttached && !Launched)
            Debugger.Launch();
        Launched = true;
    }
}